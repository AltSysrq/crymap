Crymap -- A simple, secure IMAP server with encrypted data at rest

* Motivation

uw-imap (University of Washington IMAP) is no longer maintained, and UW has
even removed it from their site.

Other IMAP implementations are much more complex to set up and are still prone
to security issues.

Nothing really supports encryption at rest.

* Goals

No unsafe code other than OpenSSL itself.

Minimal configuration: Logging, location of user database, port to listen on.
Per user, password hash, encryption information, location of user data and
optional UID to switch to.

IMAPS only. No support for cleartext or STARTTLS.

User data is stored in a way that makes it amenable to online backup (as with
rsync or ensync); i.e., don't shove everything into a huge sqlite database or
something.

Encryption at rest. All user data is encrypted and can only be accessed by
knowing the user's password (hence we can't use PAM authentication,
unfortunately, since we'd lose the encryption key when the password changed).
Encryption is done in a public-private key system so that mail can be delivered
without needing the decryption key. Encryption at rest protects from
compromising of disk contents but not shell access since shell access could
probe process memory and recover the key that way, so this does not fully
replace using pgpipe --- we'll just layer both together. This also precludes
using nginx to do TLS termination since it wants to be able to handle auth
itself.

Make Thunderbird happy. Other mail frontends are nice-to-have but no point in
using a time to test them.

* Non-Goals

Performance. It's nice to have, but simplicitly is more important for security.

Resistance to DoS from logged in users.

Supporting message mutations like deletion of attachments.

* User data format

Encryption at rest makes it impossible to be interoperable with any other
mailbox format (mbox, maildir, ...), so we're going to be doing our own thing
regardless.

We need to support these attributes for IMAP:

- UID. 32-bit integer uniquely identifying the message, strictly incrementing.
  We need to be able to remember UIDs that were used in the past.

- Sequence number. Volatile, per-session identifier. The ire of IMAP
  implementors everywhere. Nothing to store here since it's volatile.

- System flags: \Seen, \Answered, \Flagged, \Deleted, \Draft, \Recent. These
  need to be queriable reasonably efficiently and must be mutable on a
  per-message basis.

- Keyword flags (represented by \* in PERMANENTFLAGS). Need to be easily
  readable but not necessarily efficiently searchable. Need to be able to be
  defined permanently by the client. Also need to be mutable on a per-message
  basis.

- Internal date. Just a timestamp we can embed somewhere.

- Message size. The physical size of the RFC-2822 message. We need this for
  framing regardless.

- Envelope structure, body structure, message text. We can just parse stuff out
  of the RFC-2822 message on-demand.

Each mailbox will be a directory. Names need not be encrypted since delivery
needs to be able to determine mailbox names without the decryption key anyway.

Each directory contains 256 subdirectories, 00 through ff. Each message is a
single file in one of those, where the directory name represents the low 8 bits
of its UID, and the file name is the upper 24 bits of the UID in byte-wise
little-endian order. Expunged messages are represented by an empty file.

A message consists of the following:

- An encryption block, giving any information needed to decrypt the message
  (other than the key of course).

- Immutable metadata, encrypted. Probably just the timestamp and size of the
  message (both compressed and plaintext) but there might be other stuff to put
  here.

- The message data. Encrypted after compression, RFC-2822 format.

** Mutable metadata

There's a number of ways this could be done.

Important criteria:

- Determining which flags are set on a message should require at most linear
  system calls with respect to the number of flags that could be set.

- Determining which messages are have or do not have a particular flag must
  require sub-linear system calls with respect to the number of messages that
  will be found.

- The system needs to be amenable to naïve backup files. Tearing in directory
  contents or within incrementally updated files must be safe.

- Holding everything in memory is not ideal, and if this is done, it must have
  a reasonably compact representation.

There's also some mutable metadata for the mailbox itself which must be
tracked, though this is not performance sensitive and does not need to solve
the same race conditions:

- Whether the mailbox has one of the special mailbox flags (i.e., \Sent and
  friends).

- Whether the mailbox is subscribed.

Disposition: Item stream CRDT is complex and inefficient. The security benifits
it provides are tangible but small, since the more widely-used message
classification system, mailboxes, is already fully transparent. We'll go with
unencrypted bitmaps.

*** Item stream CRDT

Mutable attributes like flags are tracked separately. Each mailbox has a "meta"
subdirectory. The meta subdirectory contains any number of mutation files
representing changes to mutable attributes.

Each mutation file is symmetrically encrypted (since there is no reason for
unauthenticated processes to modify it). It starts with the timestamp of its
creation, and then a sequence of encrypted blocks (framed so the file can be
progressively appended to). Each block gives a timestamp and a mutation. By
reading all mutations into memory and sorting by total order, every process can
determine the mutable status of every message.

Mutation files have a maximum lifetime. After that point, the owner must stop
writing the file and make a new one. After more time still, extra files can be
garbage-collected by any process, simply by writing a new mutation file without
redundant information and deleting the old ones. This system also encodes
metadata about the mailbox itself.

Flag queries are performed by loading all the metadata into memory in a
collapsed form and then looking at the in-memory representation.

A mailbox directory with no "meta" subdirectory is a \Noselect mailbox.
Mailboxes with children are subsubdirectories under a "sub" subdirectory.

A mailbox directory with neither "meta" nor "sub" is considered to not exist.
This is needed to support subscribing to deleted mailboxes.

Subscriptions are indicated by an empty "subscription" file inside the mailbox
directory.

This is overall a fairly complex option, particularly since rollup must be done
in multiple stages to avoid backup solutions seeing a torn view and losing the
metadata.

*** Message flags as bitsets

Each flag is stored in a single file, which contains an encrypted bitmap keyed
by UID. Determining whether a flag is on a message is simply a matter of
seeking to the correct block, reading and decrypting it, and looking at the
bit for that message. Finding the UIDs with a flag is simply a matter of
scanning the file.

The security of this system is moderate at best. Even with 128 messages
represented per block, an adversary can get a good idea of when certain
messages get certain flags, and can trivially see which message are not even
covered by the bitset based on its length.

Updates are trickier due to their read-modify-write nature. We'd need to use
file locking to prevent processes from stepping on one another's toes.
Alternatively, if we use a stream cipher (of sorts) and one byte per message,
writes would be atomic and would not be RMW. This does make the system even
more transparent though, since each byte takes on one of two values.

A final alternative is to be completely transparent and not encrypt anything at
all here. This isn't entirely weird since mailbox names are also transparent.
This turns this option into the simplest thing we could possibly do.

Interaction with naïve backup systems is easy though, since writing a single
block will be atomic and torn updates are otherwise safe.

** Alternate design for CONDSTORE and QRESYNC support

CONDSTORE and QRESYNC are a nice-to-have, but were rejected in the original
design because they require assigning a unique, strictly ascending 63-bit value
to every operation in the mailbox.

On further consideration, building the design around this may make things
simpler in the long run. A key simplification is that we do not need to take
any 63-bit sequence number and point to the change; we only need to know what
messages have changed since that time, and to support conditional store.

Thoughts:

The message store can stay exactly as it is currently, except with
`expunge-log` removed. The pre-built seqnum index is also removed. Expunge
"events" are pushed up into the "change store".

The "change store" is similar to the "message store", but stores encrypted
changesets identified by 31-bit change-ids (CID). Changes are things such as
additions and removals of tags and expungement of messages. We have a rollup
system (TODO) which folds changes into single rollup files which also serve as
a cache for the set of extant UIDs.

A Modseq has the greatest UID in the upper 32 bits and the greatest CID in the
lower 32 bits. The modseq is thus effectively a 2-element vector clock,
allowing messages to be inserted asynchronously from other changes.

The modseq at the instant a message is inserted is considered to have a CID
of 0. However, we do not track UID-CID relations. The "current" modseq is
always the greatest UID and greatest CID. Conditional stores are only strictly
conditional on the CID, but this is fine since it is impossible for the client
to observe the absolute ordering between their conditional change and the
creation of the new message.

A message is "changed since" a modseq if the UID part is less than the UID of
the message or if any changes after the CID of the modseq affected that
message.

One quirk here is that each message is considered to have a "last changed
modseq", but we only track the CID. (We can't associate a "canonical UID" with
each change since that would be racy and could yield out-of-order events.) This
leaves us between a rock and a hard place: we could synthesise the modseq by
pasting the CID to the _latest_ UID, but then a client that sees the new modseq
and does a `CHANGEDSINCE` query will not get the message.

We can probably virtualise it: If the client FETCHes a modseq for a message, we
store (in memory) the modseq that was returned, and act on that in future
requests. This would still be observable to cross-session activity though.

Actually, we *should* be able to store the canonical UID with each modseq: if
the writer of a change loses the race for a CID, it must first read in any new
modifications and in doing so will learn of any later UIDs.

Rollups. Whenever an instance ingests a change whose id is an even multiple of
256, it dumps the current state, including the last UID it knows about and the
extant UID list, into a file which is a sibling to the directory containing the
last 256 changes. The rollup excludes flags for expunged messages and all but
the last of any explicit expunge events (because CONDSTORE/QRESYNC does not
require remembering them). Old rollup files and the original events can be
garbage collected 24 hours after a rollup including them has been generated.

What this whole system makes easier implementation-wise is that there are now
only two places to watch for realtime changes: the file corresponding to the
next UID, and the file corresponding to the next CID. It also reduces the
number of bespoke binary formats and gets us reasonably good encryption of
message attributes. We do end up holding all information about flags in memory,
but we probably would have ended up needing to do something like that anyway.

* Overall data layout

The root of system data is a directory.

The system data directory contains a "users" subdirectory. This in turn has one
symlink or subdirectory for each username that is allowed to log in. User
directories do not need to be on the same filesystem as the system data
directory. The system data directory also holds "crymap.toml" which defines the
rest of the system configuration.

The user directory contains the following:

- "mailboxes", a subdirectory containing the user data (see previous section)
- "config.toml", a text file holding various user config, including password
  hash and encryption information and the names of special mailboxes.
- "keys", a directory containing encrypted private key blobs and cleartext
  public key blobs
- "tmp", a subdirectory used for temporary buffers and for staging files before
  moving them into place

* IMAP Extensions

uw-imap advertises these:
IMAP4rev1 IMAP4 AUTH=LOGIN AUTH=CRAM-MD5 IDLE CHILDREN UIDPLUS

ID [RFC2971], to exchange implementation info with the server

IDLE [RFC 2177]

UTF8=ONLY [RFC6855], so we don't need to deal with the obsolete UTF-7 stuff.
TODO: Does Thunderbird actually support this? Looks like it doesn't, oh well.
We should try to implement UTF8=ACCEPT at least though.

ENABLE [RFC5161], for clients to acknowledge UTF8=ONLY

MOVE, moving messages instead of COPY+delete+EXPUNGE
https://tools.ietf.org/html/draft-krecicki-imap-move-01

UIDPLUS [RFC 4315], base more things around UIDs instead of sequence numbers

QRESYNC [RFC 5162] is attractive in goal, but brings along an oodle of baggage,
so let's not.

BINARY [RFC 3516] sounds since since it's another thing about ditching old
limitations, but it allows the client to force the server to transcode MIME
messages, so no. (On the other hand, IMAP4rev2 (draft) requires this...)

CHILDREN [RFC 3348] just adds mailbox attributes indicating whether or not each
mailbox has children, so that's easy enough.

COMPRESS [RFC 4978] might be nice.

WITHIN [RFC 5032] adds a couple search filters based on relative timestamps.
Pretty trivial.

LITERAL- [RFC 7888], avoid client-server round-trip for binary literals <= 4096
bytes with special syntax. Though apparently it's not widely supported, and
IMAP4rev2 (draft) requires LITERAL+, so I guess we'll do that.

XLIST and related [RFC 6154], for the special mailbox markers.
https://bugzilla.mozilla.org/show_bug.cgi?id=476260

UNSELECT [RFC 3691], to close a mailbox without expunging it

REPLACE [RFC 8508], a simple APPEND + UID EXPUNGE command.

APPENDLIMIT [RFC 7889], a completely passive way for the server to indicate the
maximum allowable APPEND size.

SASL-IR [RFC 4959], allows the client to send its auth immediately instead of
going through a continuation round-trip. Pretty trivial.

NAMESPACE [RFC 2342]. It's trivial for what we're doing.

SEARCHRES [RFC 5182] might be worth doing just because IMAP4rev2 will probably
require it.

ESEARCH [RFC 4731] is also incorporated into IMAP4rev2.

LIST-EXTENDED [RFC 5258] is also incorporated into IMAP4rev2.

[RFC 5530] defines additional error codes.

IMAP4rev2 draft: https://datatracker.ietf.org/doc/draft-ietf-extra-imap4rev2/?include_text=1

* Special mailboxes

Inbox. Undeletable, unrenamable, flagged \Inbox. Name must be case-insensitive.
Renaming has a weird special case in that we must support it, but do so by
creating a new mailbox with the new name and moving all contents inside Inbox
into it, while leaving any child mailboxes of Inbox unaffected. There doesn't
seem to be a particularly strong reason to implement this.

Sent. Undeletable, flagged \Sent.

Junk. Undeletable, flagged \Junk.

Trash. Undeletable, flagged \Trash.

* Operational design

One process per connection. This has a lot of advantages, such as being able to
switch users once authenticated, isolating unrelated connections from eaech
other, making it possible to see sources of load in `top`, and simplicity.

Processes can be spawned by inetd or similar, making daemonisation unnecessary.

If UNIX-specific features are enabled, the process can be configured to chroot
into the system data directory after all resources needed are loaded but before
anything on the socket is read, to insulate from OpenSSL vulnerabilities. After
authentication, it can further optionally chroot into the user directory and
switch to a particular UID. These features of course require spawning the
process as root. Some installations may prefer to just run under a dedicated
service user.

* Encryption

Symmetric encryption is done with AES-128-GCM, except for mutable metadata
files, which use AES-128-CBC since it is more suitable for incremental updates
and less sensitive in general.

An encrypted blob starts with a 16-byte IV and is followed by the ciphertext
with 0-padding. In GCM mode, this is followed by the 16-byte AEAD tag.

Asymmetric encryption is done through RSA. This adds a prefix to the encrypted
blob:

- The public/private key pair name, terminated with LF
- Two bytes (LE u16) indicating the length of the next component
- The 16-byte encryption key of what follows, itself encrypted with RSA using
  PKCS1-OAEP padding.

A user can have any number of keys, each of which has a name. Keys may be
"internal" if the public key is not stored in cleartext, or "external" if it
is.

Each private key is stored in the user's "keys" directory at "$name.priv". It
is an encrypted blob containing the RSA key's DER format, encrypted with the
user's master key. External public keys are stored in "$name.pub" in PEM PKCS#1
format.

The master key is a 16-byte value generated randomly generated when the user is
created. At runtime, it is derived from the user's password indirectly.

The user's password is passed through Argon2, using parameters and salt stored
in the user config to produce the password hash. The user config stores the
SHA-3 of the password hash with "check" appended in order to verify the
password. The master key is derived by taking the SHA-3 hash of the password
hash with "master" appended and then XORing it with a "master key XOR" stored
in the user config. The first 16 bytes of the result are the master key. The
master key XOR makes it possible to change the password without invalidating
the data.

* Internal Architecture

`crypt`. Shared crytographic primitives.

`mailbox`. Implementation of the basic mailbox storage mechanism, including
mutable metadata and sequence numbers, but not including functionality
involving parsing of MIME messages (e.g. partial FETCH, SEARCH elements),
instead only providing a feature to stream cleartext messages out of the store.

`mime`. Minimal parsing of MIME messages. We might pull this out of pgpipe.

`imap`. Implementation of IMAP operations, but nothing to do with the wire
protocol. Ties `mailbox` and `mime` together.

`wire`. Definitions for working with the IMAP wire protocol, with full support
for server-side parsing/serialisation and enough support for client-side to
support the CLI.

`server`. Actual IMAP server implementation. Ties `imap` and `wire` together.

`cli`. Various CLI utilities.
* On parsing MIME

IMAP unfortunately requires the server to actually parse MIME content in
certain cases, particularly for structured `FETCH` and many `SEARCH` queries.

How /little/ can we get away with? A full MIME parser is complex and
error-prone.

Inventory: What can the client ask the server to extract?

- FETCH: BODYSTRUCTURE. Also known as BODY, which confusingly is different from
  BODY[section]. This is a tree representing the multipart structure (including
  recursing into `message/rfc822` attachments for some reason). The exact
  format of the body structure varies wildly with content type. It's mostly
  stuff from the simple message headers, but also the size of certain types
  (measured in bytes or *lines* depending on type), and in one case the MD5 of
  the content (though that is extension data, which is apparently optional). So
  while formatting this the way IMAP wants is going to be ridiculously complex,
  getting the data itself should be fairly easy.

- FETCH: BODY[]. Fetches a (possibly filtered) part of the message. The client
  can optionally select a multipart section, and then can choose between all
  headers, some specific headers, all but some specific headers, the content
  only, or the whole section. Additionally, the client can request a
  byte-slice, which can just be handled after the whole byte array is buffered.

- FETCH: ENVELOPE. Grab a smorgasboard of headers and, for reasons unknown,
  reencode them into IMAP's own syntax. This includes fields that can contain
  non-ASCII characters in 8BITMIME, which is potentially problematic. These
  also require a deeper understanding of MIME and.. SMTP? syntax. There's also
  `Subject` which may require decoding.

- SEARCH: BCC, CC, FROM, TO. Primary headers that only need rudimentary
  parsing for the search match.

- SEARCH: SENTBEFORE, SENTON, SENTSINCE. The `Date` header. There's some
  ambiguity regarding timezone but is otherwise unproblematic.

- SEARCH: SUBJECT. We need to decode the subject if it's in one of the wonky
  non-ASCII encoding schemes.

- SEARCH: TEXT. Search the entire content, headers and all. RFC 3501 does not
  indicate whether the server is expected to know how to decode the body. We'll
  assume no. Server-side text search will be slow and is undeniably the wrong
  approach here so it's not that important to fully support.

Overall, BODYSTRUCTURE and ENVELOPE are both apalling and will be, by a wide
margin, the biggest difficulty here.
