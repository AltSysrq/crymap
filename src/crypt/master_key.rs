//-
// Copyright (c) 2020, Jason Lingle
//
// This file is part of Crymap.
//
// Crymap is free software: you can  redistribute it and/or modify it under the
// terms of  the GNU General Public  License as published by  the Free Software
// Foundation, either version  3 of the License, or (at  your option) any later
// version.
//
// Crymap is distributed  in the hope that  it will be useful,  but WITHOUT ANY
// WARRANTY; without  even the implied  warranty of MERCHANTABILITY  or FITNESS
// FOR  A PARTICULAR  PURPOSE.  See the  GNU General  Public  License for  more
// details.
//
// You should have received a copy of the GNU General Public License along with
// Crymap. If not, see <http://www.gnu.org/licenses/>.

//! Code for working with master keys.
//!
//! Each user has a single, unalterable master key which is generated when the
//! user is created. The master key is derived from the user's password in a
//! way that allows the password to be changed at any time.
//!
//! To derive the master key, the password is first hashed with a standard
//! salted password hashing algorithm (see `Algorithm`). That raw hash is then
//! hashed again with two different suffixes to produce the final password hash
//! and the "derived key".
//!
//! The final password hash is stored in the user configuration, and makes it
//! easy to determine whether the input password is correct.
//!
//! The "derived key" is XORed with another byte array, the "master key XOR",
//! also stored in the user config, to derive the master key. This makes it
//! possible for arbitrary passwords to derive arbitrary master keys.
//!
//! The master key is used for things requiring symmetric encryption, such as
//! private keys and item streams.

use rand::{rngs::OsRng, Rng};
use serde::{Deserialize, Serialize};
use tiny_keccak::{Hasher, Sha3};

use super::AES_BLOCK;
use crate::support::user_config::b64;

#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq)]
#[allow(non_camel_case_types)]
pub enum Algorithm {
    /// Use the Argon2i 1.3 algorithm with a memory cost of 4MB, time cost of
    /// 10, 1 lane, and a hash length of 32, with no associated data or secret.
    ///
    /// The final password hash is `SHA3(argon2_hash ++ "check")`. The derived
    /// key is `SHA3(argon2_hash ++ "master")`.
    Argon2i_V13_M4096_T10_L1,
}

impl Default for Algorithm {
    fn default() -> Self {
        Algorithm::Argon2i_V13_M4096_T10_L1
    }
}

/// Configuration which represents the derivation of the master key.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct MasterKeyConfig {
    /// The hash of the password.
    #[serde(with = "b64")]
    password_hash: Vec<u8>,
    /// The salt used to hash the password.
    #[serde(with = "b64")]
    salt: Vec<u8>,
    /// The algorithm used to generate this particular password hash.
    algorithm: Algorithm,
    /// Sequence of bytes XORed with the key derived from the password to
    /// obtain the master key.
    ///
    /// Currently, this is expected to always be exactly 16 bytes long.
    #[serde(with = "b64")]
    master_key_xor: Vec<u8>,
}

/// A randomly generated, AES-128 key.
///
/// Each user has a single, unalterable master key. See the module
/// documentation for more information.
#[derive(Clone, Copy)]
pub struct MasterKey {
    pub(super) key: [u8; AES_BLOCK],
}

impl MasterKey {
    /// Generate a new master key.
    pub fn new() -> Self {
        MasterKey { key: OsRng.gen() }
    }

    /// Given this key and a password, generate a `MasterKeyConfig` which can
    /// be used with that password to re-derive this key.
    ///
    /// The salt is randomly generated each call, so repeated calls will not
    /// yield identical objects.
    pub fn make_config(
        &self,
        password: &[u8],
    ) -> Result<MasterKeyConfig, argon2::Error> {
        let salt: [u8; 32] = OsRng.gen();
        let (password_hash, derived_key) =
            hash_password(password, &salt, Algorithm::default())?;

        let mut master_key_xor = vec![0u8; AES_BLOCK];
        for i in 0..AES_BLOCK {
            master_key_xor[i] = self.key[i] ^ derived_key[i];
        }

        Ok(MasterKeyConfig {
            password_hash: password_hash[..].to_owned(),
            salt: salt[..].to_owned(),
            algorithm: Algorithm::default(),
            master_key_xor,
        })
    }

    /// Given a `MasterKeyConfig` generated by `make_config()` and a password,
    /// attempt to derive a `MasterKey`.
    ///
    /// Returns `None` if derivation fails for any reason.
    pub fn from_config(
        conf: &MasterKeyConfig,
        password: &[u8],
    ) -> Option<Self> {
        let (password_hash, derived_key) =
            hash_password(password, &conf.salt, conf.algorithm).ok()?;

        if password_hash.len() != conf.password_hash.len()
            || !openssl::memcmp::eq(&password_hash, &conf.password_hash)
            || AES_BLOCK != conf.master_key_xor.len()
        {
            return None;
        }

        let mut key = [0u8; AES_BLOCK];
        for i in 0..AES_BLOCK {
            key[i] = derived_key[i] ^ conf.master_key_xor[i];
        }

        Some(MasterKey { key })
    }
}

fn hash_password(
    password: &[u8],
    salt: &[u8],
    algorithm: Algorithm,
) -> Result<([u8; 32], [u8; 32]), argon2::Error> {
    let raw_hash = match algorithm {
        Algorithm::Argon2i_V13_M4096_T10_L1 => argon2::hash_raw(
            password,
            salt,
            &argon2::Config {
                hash_length: 32,
                lanes: 1,
                mem_cost: 4096,
                thread_mode: argon2::ThreadMode::Sequential,
                time_cost: 10,
                variant: argon2::Variant::Argon2i,
                version: argon2::Version::Version13,
                ..argon2::Config::default()
            },
        )?,
    };

    let mut sha3_prefix = Sha3::v256();
    sha3_prefix.update(&raw_hash);

    let mut password_hash = [0u8; 32];
    {
        let mut s = sha3_prefix.clone();
        s.update(b"check");
        s.finalize(&mut password_hash);
    }

    let mut derived_key = [0u8; 32];
    {
        let mut s = sha3_prefix.clone();
        s.update(b"master");
        s.finalize(&mut derived_key);
    }

    Ok((password_hash, derived_key))
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn rederive_master_key() {
        let orig = MasterKey::new();
        let config = orig.make_config(b"hunter2").unwrap();
        let derived = MasterKey::from_config(&config, b"hunter2").unwrap();
        assert_eq!(orig.key, derived.key);
    }

    #[test]
    fn derive_fails_for_bad_password() {
        let config = MasterKey::new().make_config(b"hunter2").unwrap();
        assert!(MasterKey::from_config(&config, b"hunter3").is_none());
    }

    #[test]
    fn config_generation_makes_distinct_hashes() {
        let key = MasterKey::new();
        let config1 = key.make_config(b"hunter2").unwrap();
        let config2 = key.make_config(b"hunter2").unwrap();
        assert_ne!(config1.password_hash, config2.password_hash);
    }
}
